#!/usr/bin/env python
#

'''
several tools to work along drone trajectories
'''

from __future__ import print_function
import numpy as np
import pandas as pd
import datetime as dt
import struct
import glob

class Trajectory:
    '''
    class to hold trajectories data and manipulate them
    '''

    def __init__(self, fileType='geojson',
                    fileName=None,
                    directory=None,
                    motif=None):
        '''
        constructor
        '''
        knownTypes = ['geojson','binary']
        self._keys = ['year', 'month', 'day', 'hour', 'min', 'sec', 'usec',
            'gps_lat', 'gps_lon', 'gps_geoidheight', 'gps_nbsat', 'gps_altitude',
            'leddar_range', 'leddar_ampl',
            'baro_pressure', 'baro_sea_level_pressure', 'baro_altitude', 'baro_temperature',
            'imu_pitch_angle', 'imu_roll_angle']

        self._measurements = pd.DataFrame()

        if fileType not in knownTypes:
            print("I don't know how to manage this type %s of files" %fileType)
            raise ValueError()


        # loader depending on given file type/name
        if fileType == 'geojson':
            if fileName == None:
                print("a file name must be provided for geojson type")
                raise ValueError()
            else:
                self.load_json(fileName)
        elif fileType == 'binary':
            if fileName == None:
                # loading from directory + motif
                if motif==None or directory==None:
                    print("in this case, direcroty and motif are mandatory")
                    raise Exception()
                else:
                    loadBinaryFiles(directory, motif)
            else:
                self.readBinaryFile(fileName)

        # setting the index
        self._currentIndex = 0
        self._lastIndex = len(self._measurements.index)

        return None
#===============================================================================
# different loaders to accomodate various cases
    def load_json(self, fileName):
        '''
        load a Trajectory from a GeoJSON file
        '''

        # save the file it was loaded from
        self._geojsonSource = fileName

        # load the geojson file
        import geojson
        io = open(self._geojsonSource, 'r')
        self.geojson = geojson.load(io)
        io.close()

        # extract coordinates
        latitudes = []
        longitudes = []
        if self.geojson.type=='FeatureCollection':
            for feature in self.geojson.features:
                coordinates = feature.geometry.coordinates
                for c in coordinates:
                    latitudes.append(c[1])
                    longitudes.append(c[0])

        # for the sake of example, generate fake data
        # fake date range
        hdMeas = dict()
        dates = pd.date_range(start='1/1/2016', periods=len(latitudes), freq='s')
        # fake data except for lat & lon
        for key in self._keys:
            if key == 'gps_lon':
                hdMeas[key] = longitudes
            elif key =='gps_lat':
                hdMeas[key] = latitudes
            else:
                hdMeas[key] = self._generateDummyData(len(latitudes))

        self._measurements = pd.DataFrame(hdMeas, index=dates)
        return 0

    def readBinaryFile(self, filename):
        '''
        load from a binary file generated by HMK1
        '''

        # expected structure of the file
        Structure = "<HBBBBBIfffIffIffffff"
        s = struct.Struct(Structure)
        sizeMeas = struct.calcsize(Structure)

        # init the output dictionnary
        hdMeas = dict()

        for key in self._keys:
            hdMeas[key] = []

        # open the file
        try:
            hdFile = open(filename,"rb")
        except IOError:
            raise

        # loop through the file
        nbMeasures = 0
        try:
            while True:
                measure = hdFile.read(sizeMeas)
                if len(measure) != sizeMeas:
                    break

                # Recuperation des donnees
                readMeasure = s.unpack(measure)
                hdMeas['year'].append(readMeasure[0])
                hdMeas['month'].append(readMeasure[1])
                hdMeas['day'].append(readMeasure[2])
                hdMeas['hour'].append(readMeasure[3])
                hdMeas['min'].append(readMeasure[4])
                hdMeas['sec'].append(readMeasure[5])
                hdMeas['usec'].append(readMeasure[6])
                hdMeas['gps_lat'].append(readMeasure[7])
                hdMeas['gps_lon'].append(readMeasure[8])
                hdMeas['gps_geoidheight'].append(readMeasure[9])
                hdMeas['gps_nbsat'].append(readMeasure[10])
                hdMeas['gps_height_above_geoid'].append(readMeasure[11])
                hdMeas['leddar_range'].append(readMeasure[12])
                hdMeas['leddar_ampl'].append(readMeasure[13])
                hdMeas['baro_pressure'].append(readMeasure[14])
                hdMeas['baro_sea_level_pressure'].append(readMeasure[15])
                hdMeas['baro_altitude'].append(readMeasure[16])
                hdMeas['baro_temperature'].append(readMeasure[17])
                hdMeas['imu_pitch_angle'].append(readMeasure[18])
                hdMeas['imu_roll_angle'].append(readMeasure[19])
                nbMeasures += 1

        except IOError:
            print("Erreur de lecture de la mesure")
            pass

        # convert the dates to datetime object
        dates = [dt.datetime(hdMeas['year'][i],
                                hdMeas['month'][i],
                                hdMeas['day'][i],
                                hdMeas['hour'][i],
                                hdMeas['min'][i],
                                hdMeas['sec'][i],
                                hdMeas['usec'][i]) for i in np.arange(nbMeasures)]

        # store the values in the Object
        df = pd.DataFrame(hdMeas, index=dates)
        self._measurements =  pd.concat(self._measurements, df)

        return 0

    def loadBinaryFiles(self, directory, motif):
        '''
        reads from binary measurement files in a directory
        '''
        filesToRead = sorted(glob.glob("%s/%s" %(directory, motif)))

        for f in filesToRead:
            dates, hdMeas = readBinaryFile(f)
        return 0

    def _generateDummyData(self, length):
        '''
        generate dummy data
        '''
        return np.arange(length)*(-0.0003)+np.random.randn(length)
        return 0

#==============================================================================
# functions to travel along a trajectory
    def travel(self, delay=0.1):
        '''
        travels along the trajectory
        '''
        while self._oneStepTravel()==0:
            return self._current_position
            time.sleep(delay)
        return 0

    def _oneStepTravel(self, loop=True):
        '''
        moves from the current index to the next one
        '''

        if self._currentIndex < len(self._measurements.index)-1:
            self._currentIndex += 1
        else:
            if loop:
                self._currentIndex = 0
            else:
                print("end of trajectory reached")
                return 1
        return 0

#===============================================================================
# some access to values (other than pandas methods)
    def pastTimes(self):
        """
        returns all past times as a flattened array
        """
        return np.array(self._measurements.index.values[0:self._currentIndex])

    def pastValues(self, key):
        """
        returns all past values of a key as a flattened array
        """
        if key not in self._keys:
            print("There is no such key: " %key)
            raise Exception()
        else:
            return(self._measurements[key].values[0:self._currentIndex])

    def pastPositions(self):
        """
        returns all past positions as a flattened array
        """
        return np.array(self._pastPositions)

    def foliumShow(self, out):
        '''
        plot the trajectory using folium
        '''
        import folium
        m = folium.Map([43, 10], zoom_start=4, tiles='Stamen Toner')
        folium.GeoJson(self.geojson).add_to(m)
        m.save(out)

    def bokehSeries(self):
        return 0

    def createFoliumMarker(self,
            color='green',
            icon='stats',
            max_width=2650,
            location='current',
            width=500,
            height=250):
        '''
        return a folium marker with the measurements of the trajectory
        '''
        from bokeh.plotting import figure
        from bokeh.resources import CDN
        from bokeh.embed import file_html
        import folium
        from folium.element import IFrame

        # get the marker location
        if location=='current':
            location=self._current_position

        elif location=='center':
            location=self.center_position

        # create the figure of past data
        p = figure(x_axis_type="datetime",
                       width=width, height=height)
        p.line(self.pastTimes(), self.pastValues(), line_width=2)

        html = file_html(p, CDN, "marker")
        iframe = IFrame(html, width=width+40, height=height+80)
        popup = folium.Popup(iframe, max_width=max_width)
        icon = folium.Icon(color=color, icon=icon)

        marker = folium.Marker(location=[location[1],location[0]],
                                   popup=popup,
                                   icon=icon)
        return marker
